{
    "_id": "0GU2sdy3r2MeC56x",
    "actorIds": [],
    "author": "4rlSA43v1xPa1vsy",
    "command": "const toChat = (actorName, content) => {\n  const chatData = {\n    user: game.user.id,\n    content,\n    speaker: { alias: actorName }\n  };\n  ChatMessage.create(chatData, {});\n};\n\nconst recover = () => {\n  const entryTypePattern = /^(Focus|Prepared|Spontaneous|Innate)[\\w ]+Spells$/;\n  const Character = CONFIG.PF2E.Actor.entityClasses.character;\n  const Condition = CONFIG.PF2E.Item.entityClasses.condition;\n  const tokens = canvas.tokens.controlled.filter((token) => token.actor instanceof Character);\n\n  if (tokens.length === 0) {\n    ui.notifications.warning(\"Select at least one token.\");\n  }\n\n  for (const token of tokens) {\n    const actor = token.actor;\n    const actorData = duplicate(actor.data);\n    const actorItems = Array.from(actor.items.values());\n    const abilities = actorData.data.abilities;\n    const attributes = actorData.data.attributes;\n\n    // Hit points\n    const conModifier = abilities.con.mod;\n    const level = actorData.data.details.level.value;\n    const maxRestored = Math.max(conModifier, 1) * level;\n    const hpLost = attributes.hp.max - attributes.hp.value;\n    const actualRestored = hpLost >= maxRestored ? maxRestored : hpLost;\n    attributes.hp.value += actualRestored;\n\n    const hpRestoredMsg = actualRestored > 0 ?\n          `${actualRestored} hit points restored.` :\n          \"Already at full hit points.\";\n\n    // Fatigued condition\n    const fatigued = actorItems.find((item) => (item.type === \"condition\" &&\n                                                item.getFlag(\"pf2e\", \"condition\") &&\n                                                item.name === \"Fatigued\"));\n    const fatiguedMsg = (() => {\n      if (fatigued instanceof Condition) {\n        PF2eConditionManager.removeConditionFromToken(fatigued.id, token);\n        return \"No longer fatigued.\";\n      }\n      return \"\";\n    })();\n\n    // Spellcasting entries\n    const restoredList = [ ];\n    const entries = actorItems.filter(\n      (item) => item.type === \"spellcastingEntry\" && entryTypePattern.test(item.name)\n    );\n    const entriesUpdateData = entries.flatMap((entry) => {\n      const entryType = entry.name.match(entryTypePattern)[1];\n\n      // Focus spells\n      if (entryType === \"Focus\") {\n        const focusPool = duplicate(entry.data.data.focus);\n        if (focusPool.points < focusPool.pool) {\n          focusPool.points = focusPool.pool;\n          restoredList.push(\"Focus Pool\");\n          return { _id: entry.id, \"data.focus\": focusPool };\n        }\n\n        return [];\n      }\n\n      // Innate, Spontaneous, and Prepared spells\n      const slots = entry.data.data.slots;\n      let updated = false;\n      for (const slot of Object.values(slots)) {\n        if ([\"Innate\", \"Spontaneous\"].includes(entryType)) {\n          if (slot.value < slot.max) {\n            slot.value = slot.max;\n            updated = true;\n          }\n        } else {\n          for (const preparedSpell of Object.values(slot.prepared)) {\n            if (preparedSpell.expended) {\n              preparedSpell.expended = false;\n              updated = true;\n            }\n          }\n        }\n      }\n\n      if (updated) {\n        restoredList.push(entry.name);\n        return { _id: entry.id, \"data.slots\": slots };\n      }\n      return [];\n    });\n\n    actor.updateOwnedItem(entriesUpdateData);\n\n    // Stamina points\n    const staminaEnabled = Boolean(\n      parseInt(game.settings.storage.get(\"world\").get(\"pf2e.staminaVariant\").replace(/\"/g, \"\"), 10)\n    );\n    if (staminaEnabled) {\n      const stamina = attributes.sp;\n      const keyAbility = actorData.data.details.keyability.value;\n      if (stamina.value < stamina.max) {\n        stamina.value = stamina.max;\n        restoredList.push(\"Stamina\");\n      }\n      const resolve = attributes.resolve;\n      const maxResolve = abilities[keyAbility].mod;\n      if (resolve.value < maxResolve) {\n        resolve.value = maxResolve;\n        restoredList.push(\"Resolve\");\n      }\n    }\n\n    const restoredString = restoredList.length === 0 ? \"\" :\n                           restoredList.length === 1 ? `${restoredList[0]}` :\n                           restoredList.length === 2 ? `${restoredList.join(\" and \")}` :\n                           (`${restoredList.slice(0, -1).join(\", \")}, and ` +\n                            `${restoredList.slice(-1)[0]}`);\n    const restoredMsg = restoredList.length > 0 ? ` ${restoredString} fully restored.` : \"\";\n\n    // Make actor updates and send message\n    actor.update({ \"data.attributes\": attributes });\n\n    const messages = [hpRestoredMsg, fatiguedMsg, restoredMsg].filter((message) => message !== \"\");\n    toChat(actor.name,\n           `${actor.name} awakens fully rested. ${messages.join(\" \")}`);\n  }\n};\n\nnew Dialog({\n  title: \"Rest\",\n  content: \"<p>Rest for the night?</p>\",\n  buttons: {\n    yes: {\n      icon: '<i class=\"fas fa-check\"></i>',\n      label: \"Rest\",\n      callback: recover\n    },\n    no: {\n      icon: '<i class=\"fas fa-times\"></i>',\n      label: \"Cancel\"\n    },\n  },\n  default: \"yes\"\n}).render(true);",
    "flags": {},
    "img": "icons/svg/sleep.svg",
    "name": "Rest for the Night",
    "permission": {
        "default": 0
    },
    "scope": "global",
    "type": "script"
}
